\chapter{Технологическая часть}

В данном разделе будут приведены требования к программному обеспечению, средства реализации и листинги кода.

\section{Требования к программе}

Программа должна предоставлять следующие возможности:
\begin{itemize}
	\item[-] визуальное отображение модели;
	\item[-] изменение положения модели в пространстве;
	\item[-] создание полигонов как части модели;
	\item[-] удаление полигонов модели;
	\item[-] изменение формы модели;
	\item[-] сохранение модели в файл;
	\item[-] чтение модели из файла;
	\item[-] изменение цвета грани модели;
\end{itemize}

\section{Язык программирования и среда разработки}

%В качестве языка программирования для реализации ПО был выбран язык программирования Kotlin \cite{kotlin}. 

%В данном языке есть все требующиеся для данной лабораторной инструменты разработки.

Для реализации проекта в качестве языка программирования был выбран Kotlin \cite{kotlin} — статически типизированный, объектно-ориентированный язык программирования, работающий поверх Java Virtual Machine и разрабатываемый компанией JetBrains.

%Kotlin был разработан с целью заменить Java и сделать разработку приложений, основанных на JVM более быстрой и безопасной.

%Когда язык Java только появился, он был гораздо проще и лаконичнее конкурентов — тех же C и C++. Да у него и сейчас достаточно понятный и логичный синтаксис — правда, по современным меркам этот язык уже кажется многословным и несколько старомодным. Это и неудивительно: в Java всё вертится вокруг обратной совместимости, которая так важна для энтерпрайза, в котором «кофейный» язык является стандартом.

Создатели Kotlin изначально делали ставку на компактность: чем меньше ненужного кода, тем проще работать программисту и тем быстрее идёт разработка.

Таким образом Kotlin сочетает в себе преимущества годами увеличивающегося списка готовых решений для Java и лаконичности, безопасности и быстродействия современных языков программирования, к которым и принадлежит Kotlin.

В качестве среды разработки была выбрана среда IntelliJ IDEA\cite{idea}, запуск происходил через средство разработки.

\section{Структура программы}

Так как разработка велась на структурно-ориентированном языке программирования, особое внимание уделено структуре классов.

\begin{itemize}
	\item Математические абстракции.
	\begin{itemize}
		\item Vector3 --- четырехмерный вектор $(x, y, z, w)$.
		\item Matrix --- матрица $4 \times 4$.
	\end{itemize}
	\item Объекты.
	\begin{itemize}
		\item SimpleObject --- абстрактный класс объекта сцены.
		\item Vertex --- вершина, задается вектор Vector3 и матрицей поворота Matrix.
		\item Edge --- ребро, заданное двумя вершинами Vertex.
		\item Facet --- грань, заданная тремя вершинами Vertex и тремя ребрами Edge.
		\item PartsOfModel --- контейнер, содержащий все грани Facet, ребра Edge и вершины Vertex модели.
		\item Model --- модель, хранилище PartsOfModel.
	\end{itemize}
	\item Классы сцены.
	\begin{itemize}
		\item Scene --- класс, хранящий модель.
		\item Render --- класс для создания изображений.
	\end{itemize}
	\item Интерфейс пользователя.
	\begin{itemize}
		\item MainVeiw --- окно интерфейса программы.
		\item InfoView --- окно для отображения координат вершины, выбранной пользователем.
		\item WarningView --- окно для отображения сообщений об ошибке.
		\item NewFileView --- окно для сохранения модели в файл.
		\item Styles --- класс управления стилем программы.
		\item MyApp --- файл запуска приложения.
	\end{itemize}
\end{itemize}

\section{Реализация алгоритма, использующего Z-буфер}

В листинге \ref{lst:zbuff} представлена реализация алгоритма отрисовки грани, использующего Z-буфер.

\begin{lstlisting}[label=lst:zbuff,caption=Реализация алгоритма отрисовки грани\, использующего Z-буфер]
	private fun renderFacet (facet: Facet, scene: Scene, screenCenter: Vector2D, visible: Boolean) {
		val z = facet.getNormal(scene.camera, screenCenter).z
		if (z < 0) return
		val screenFacets = mutableListOf<Vector3>()
		for (v in facet.dots) {
			screenFacets += v.getScreenPos(scene.camera, screenCenter)
		}
		val frameRect = calculateFrameRect(screenFacets)
		var faceColor = calculateFacetColor(facet, scene.camera, screenCenter)
		if (facet.selected) {
			if (facet.color == Color.BLUE)
			faceColor = Color.ORANGE
			else
			faceColor = Color.BLUE
		}
		processFacet(screenFacets, frameRect, faceColor, visible)
	}

	private fun processFacet(facets: MutableList<Vector3>, rect: IntArray, color: Color, visible: Boolean) {
		val square = (facets[0].y - facets[2].y) * (facets[1].x - facets[2].x) +
		(facets[1].y - facets[2].y) * (facets[2].x - facets[0].x)
		for (y in rect[1] .. rect[3]) {
			for (x in rect[0]..rect[2]) {
				val barCoords = calcBarycentric(x, y, facets, square)
				if (barCoords.x >= 0 && barCoords.y >= 0 && barCoords.z >= 0) {
					val z = baryCentricInterpol(facets[0], facets[1], facets[2], barCoords)
					processPixel(Vector3(x.toDouble(), y.toDouble(), z), color, visible)
				}
			}
		}
	}

	fun processPixel (p: Vector3, c: Color, visible: Boolean) {
		val x = p.x.roundToInt()
		val y = p.y.roundToInt()
		if (x <= 0 || x >= width - 1)
		return
		if (y <= 1 || y >= height - 1)
		return
		if (p.z >= zBuffer[x][y]) {
			zBuffer[x][y] = p.z
			if (visible)
			pw.setColor(x, height - y, c)
		}
	}
\end{lstlisting}

\section{Интерфейс}

На рисунке \ref{img:interface} представлен интерфейс программы.

\img{95mm}{interface}{Интерфейс программы}

\FloatBarrier

Функции представленных полей следующие:
\begin{itemize}
	\item кнопки <<Поворот>> --- изменение угла поворота модели:
	\begin{itemize}
		\item кнопка <<Вверх>> --- поворот в плоскости $y0z$ на $10^{\circ}$;
		\item кнопка <<Вниз>> --- поворот в плоскости $y0z$ на $-10^{\circ}$;
		\item кнопка <<Влево>> --- поворот в плоскости $x0z$ на $10^{\circ}$;
		\item кнопка <<Вправо>> --- поворот в плоскости $x0z$ на $-10^{\circ}$;
	\end{itemize}
	\item кнопки <<Перемещение>> --- изменение положения модели:
	\begin{itemize}
		\item кнопка <<Вверх>> --- перемещение по $y$ на $10$ пикселей;
		\item кнопка <<Вниз>> --- перемещение по $y$ на $-10$ пикселей;
		\item кнопка <<Влево>> --- перемещение по $x$ на $-10$ пикселей;
		\item кнопка <<Вправо>> --- перемещение по $x$ на $10$ пикселей;
	\end{itemize}
	\item тоггл-кнопки <<Скрыть>>:
	\begin{itemize}
		\item проверочная кнопка <<Грани>> --- перестают отображаться грани модели;
		\item проверочная кнопка <<Ребра>> --- перестают отображаться ребра модели;
		\item проверочная кнопка <<Вершины>> --- перестают отображаться вершины модели;
	\end{itemize}
	\item тоггл-кнопки <<При проведении мышкой>>:
	\begin{itemize}
		\item кнопка <<Поворот>> --- при проведении мышкой модель поворачивается;
		\item кнопка <<Перемещение>> --- при проведении мышкой модель перемещается;
	\end{itemize}
	\item <<Преобразование модели>>:
	\begin{itemize}
		\item проверочная кнопка <<Начать преобразование>> --- включает режим преобразования модели;
		\item тоггл-кнопка <<Вершина>> --- становится возможным выбрать вершину модели;
		\item тоггл-кнопка <<Ребро>> --- становится возможным выбрать ребро модели;
		\item тоггл-кнопка <<Грань>> --- становится возможным выбрать грань модели;
	\end{itemize}
	\item всплывающая палитра <<Раскрасить грани>> --- выбор цвета указанной грани;
	\item <<Перемещение модели>>:
	\begin{itemize}
		\item <<Движение>> --- три поля ввода для перемещения всей модели по координатам $(x, y, z)$ соответственно;
		\item <<Поворот>> --- три поля ввода для поворота всей модели по координатам $(x, y, z)$ в градусах соответственно;
		\item кнопка <<Переместить>> --- изменение положения модели по указанным параметрам;
	\end{itemize}
	\item <<Преобразование модели>>:
	\begin{itemize}
		\item <<Движение>> --- три поля ввода для перемещения выбранных вершин/ребер/граней модели по координатам $(x, y, z)$ соответственно;
		\item кнопка <<Переместить>> --- изменение положения выбранных вершин/ребер/граней модели по указанным параметрам;
	\end{itemize}
	\item проверочная кнопка <<Ручное преобразование>> --- перемещение выбранных вершин/ребер/граней модели с помощью мышки;
	\item <<Создание новых элементов>>:
	\begin{itemize}
		\item проверочная кнопка <<Начать создание полигона>> --- включает режим создания полигона: становится возможным выбирать вершины для создания полигона;
		\item три поля ввода <<Координаты новой точки>> --- $(x, y, z)$ новой точки соответственно;
		\item кнопка <<Создать вершину>> --- создает вершину по указанным координатам, они автоматически выбраны для создания полигона;
		\item кнопка <<Создать полигон>> --- создает полигон по трем выбранным для создания полигона вершинам;
	\end{itemize}
	\item кнопка <<Удалить полигон>> --- удаляет выбранный полигон;
\end{itemize}

\section*{Вывод}

В этот разделе был выбран язык программирования и среда разработки, рассмотрены роли основных классов, подробно рассмотрен интерфейс приложения.