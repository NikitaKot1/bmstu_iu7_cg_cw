\chapter{Конструкторская часть}

\section{Алгоритм Z-буфера}

Данный алгоритм является одним из простейших алгоритмов удаления невидимых поверхностей. Впервые он был предложен Кэтмулом. Алгоритм работает в пространстве изображения, а сама идея $z$-буфера является простым обобщением идеи о буфере кадра, который используется для запоминания атрибутов или интенсивности каждого пиксела в пространстве изображения.

$Z$-буфер --- это отдельный буфер глубины, который используется для запоминания координаты $z$ или глубины каждого видимого пиксела в пространстве изображения. В процессе работы глубина или значение $z$ каждого нового пиксела, который нужно занести в буфер кадра, сравнивается с глубиной того пиксела, который уже занесен в $z$-буфере.

Если это сравнение показывает, что новый пиксел расположен впереди пиксела, который находится в буфере кадра, то новое значение заносится в буфер и производится корректировка $z$-буфера новым значением $z$. Если при сравнении получается противоположный результат, то никаких действий не производится.

Алгоритм представляет из себя поиск по $x$ и $y$ наибольшего значения функции $z(x, y)$. Формальное описание алгоритма $z$-буфера:

\begin{enumerate}[label=\arabic*)]
	\item заполнить буфер кадра фоновым значением интенсивности или цвета;
	\item провести инициализацию $Z$-буфера минимальным значением глубины;
	\item преобразовать каждый многоугольник в растровую форму в произвольном порядке;
	\begin{enumerate}
		\item для всех пикселей, которые связаны с многоугольником, вычислить его глубину $z(x, y)$;
		\item глубину пиксела сравнить со значением, которое хранится в буфере: если $z(x, y) > z_{buf}(x, y)$, то $z_{buf}(x, y) = z(x, y)$, цвет$(x, y)$ = цвет пикселя;
	\end{enumerate}
	\item отобразить результат.
\end{enumerate}

\img{210mm}{zbuff}{Схема алгоритма, использующего Z-буфер}

\FloatBarrier

\section{Модель освещения}

Для достижения наибольшей производительности в локальная модель освещения делится на две составляющие интенсивности, а именно фоновую освещенность $I_{amb}$ и диффузное отражение $I_{diff}$. Фоновое освещение это постоянная в каждой точке величина надбавки к освещению. Вычисляется следующим образом:
\begin{equation*}
	I_{amb} = k_{a} \cdot I_{a},
\end{equation*}
где $I_{amb}$ --- интенсивность отраженного Ambient-освещения, $k_{a}$ --- коэффициент в пределах от 0 до 1, характеризующий отражающие свойства поверхности для Ambient-освещения, $I_{a}$ --- исходная интенсивность Ambien-освещения, которое падает на поверхность.

Диффузное отражение это свет, отраженный гранью модели:
\begin{equation*}
	I_{diff} = I_{d} \cdot k_{diff} \cdot \cos(\theta),
\end{equation*}
где $I_{d}$ --- интенсивность падающего на поверхность света, $k_{diff}$ --- коэффициент в пределах от 0 до 1, характеризующий рассеивающие свойства поверхности, $\cos(\theta)$ --- угол между направлением на источника света и нормалью поверхности.

Конечная формула принимает вид:
\begin{equation*}
	I = I_{amb} + I_{diff} = k_{a} \cdot I_{a} + I_{d} \cdot k_{diff} \cdot \cos(\theta), 
\end{equation*}
где для более красивого и приятного изображения $k_{a} = 1$, $k_{diff} = 0.8$.

\section{Геометрические преобразования}

Для осуществления поворота и перемещения камеры используются аффинные преобразования.

Перемещение точки в пространстве:
\begin{equation*}
	\begin{cases}
		X = x + dx, \\
		Y = y + dy, \\
		Z = z + dz.
	\end{cases}
	\begin{pmatrix}
		1 && 0 && 0 && dx \\
		0 && 1 && 0 && dy \\
		0 && 0 && 1 && dz \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix}
\end{equation*}

Поворот точки в пространстве:
\begin{align*}
	\text{ось } x: 
	\begin{cases}
		X = x, \\
		Y = y \cdot \cos(\phi) + z \cdot \sin(\phi), \\
		Z = - y \cdot \sin(\phi) + z \cdot \cos(\phi).
	\end{cases}
	\begin{pmatrix}
		1 && 0 && 0 && 0 \\
		0 && \cos(\phi) && \sin(\phi) && 0 \\
		0 && -\sin(\phi) && \cos(\phi) && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
	\text{ось }  y: 
	\begin{cases}
		X = x \cdot \cos(\phi) + z \cdot \sin(\phi), \\
		Y = y, \\
		Z = - x \cdot \sin(\phi) + z \cdot \cos(\phi).
	\end{cases}
	\begin{pmatrix}
		\cos(\phi) && 0 && \sin(\phi) && 0 \\
		0 && 1 && 0 && 0 \\
		-\sin(\phi) && 0 && \cos(\phi) && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
	\text{ось }  z: 
	\begin{cases}
		X = x \cdot \cos(\phi) + y \cdot \sin(\phi), \\
		Y = - x \cdot \sin(\phi) + y \cdot \cos(\phi), \\
		Z = z.
	\end{cases}
	\begin{pmatrix}
		\cos(\phi) && \sin(\phi) && 0 && 0 \\
		-\sin(\phi) && \cos(\phi) && 0 && 0 \\
		0 && 0 && 1 && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
\end{align*}


\section{Определение принадлежности точки треугольнику}

В векторном определения принадлежности точки треугольнику методе треугольник и точка являются отображением грани и выбранной точки на область отрисовки. 

\img{50mm}{vecdot}{Определение принадлежности точки треугольнику}

\FloatBarrier

На рисунке \ref{img:vecdot} представлен принцип проверки принадлежности точки треугольнику: вектор $\overrightarrow{AP}$ должен выражаться аффинными координатами $(L; M)$, основанными на векторах $\overrightarrow{AB}$ и $\overrightarrow{AC}$. Положительность координат $L$ и $M$ гарантирует нахождение между сторонами $AB$ и $AC$ соответственно. То, что обе координаты меньше 1 и их сумма также меньше 1 гарантирует, что вектор $\overrightarrow{AP}$ не пересекает сторону $BC$.