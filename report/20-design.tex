\chapter{Конструкторская часть}

\section{Описание объектов сцены}

На рисунке \ref{img:modelpredst} видно, что модель представляет собой список вершин, список ребер, которые хранят в себе две ссылки на разные вершины, и список граней, которые хранят в себе ссылки на три разные вершины и ссылки на три грани, связывающие эти вершины.

\img{140mm}{modelpredst}{Схематичное представление хранения данных в модели}

\FloatBarrier

\section{Редактирование, создание и удаление частей модели}

\textbf{Изменение положения вершин} --- можно менять как положение отдельных вершин/ребер/граней, так и всей модели. Изменение положения вершин производится с помощью матрицы преобразования. Каждая вершина имеет собственную матрицу преобразования. Для получения нового положения вершины нужно умножить матрицу преобразования этой вершины на матрицу, соответствующую шаблону, описанному ниже.

Получение новой матрицы преобразования:
\begin{equation*}
	\begin{pmatrix}
		\text{Новая матрица} \\
		\text{преобразования } 4 \times 4
	\end{pmatrix}
	=
	\begin{pmatrix}
		\text{Текущая матрица} \\
		\text{преобразования } 4 \times 4
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		\text{Шаблонная матрица} \\
		\text{преобразования } 4 \times 4
	\end{pmatrix}
\end{equation*} 

Положение вершины в экранных координатах находится следующим образом:
\begin{equation*}
	\begin{pmatrix}
		x_{new} & y_{new} & z_{new} & w_{not~used}
	\end{pmatrix}
	=
	\begin{pmatrix}
		x_{old} \\
		y_{old} \\
		z_{old} \\
		1
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		\text{Матрица преобразования} \\
		4 \times 4
	\end{pmatrix}
\end{equation*} 

Изменение положения грани или ребра модели производится с помощью изменения положения вершин, ссылками на которые обладает грань или вершина. При этом деформируются грани и ребра, также обладающие ссылками на эти вершины:

\img{50mm}{prperemesh1}{Перемещение отдельной грани}

\FloatBarrier

\textbf{Создание новых граней} --- можно как создать несколько новых вершин, так и использовать уже имеющиеся. В этом случае новые вершины, ребра и новая грань добавляются к соответствующим спискам, хранящимся в объекте модели.

\img{50mm}{createnull}{Создание грани по трем вершинам, ранее не существующим в модели}

\FloatBarrier

\img{50mm}{create1}{Создание грани по двум вершинам, ранее не существующим в модели, и одной вершине, связанной с другими гранями}

\FloatBarrier

\img{50mm}{create2}{Создание грани одной вершине, ранее не существующей в модели, и двум вершинам, связанным с другими гранями}

\FloatBarrier

\img{50mm}{create3}{Создание грани по трем вершинам, связанными с другими гранями}

\FloatBarrier

\textbf{Удаление граней} --- удалять можно только грани, однако могут удалиться некоторые связанные с гранью ребра и вершины, если они более ни с одной из граней модели не связаны. Удаление вершин, ребер и граней происходит посредством удаления соответствующих объектов из списков, хранящимся в объекте модели.

\img{45mm}{deletingnull}{Удаление грани в случае, когда не происходит удаления вершин и ребер, принадлежащих этой грани}

\FloatBarrier

\img{40mm}{deleting1}{Удаление грани в случае, когда удаляется только одно ребро, принадлежащее этой грани}

\FloatBarrier

\img{45mm}{deleting2}{Удаление грани в случае, когда удаляется только два ребра и одна вершина, принадлежащие этой грани}

\FloatBarrier

\img{55mm}{deleting3}{Удаление грани в случае, когда удаляются все ребра и вершины, принадлежащие этой грани}

\FloatBarrier

\section{Алгоритм Z-буфера}

Данный алгоритм является одним из простейших алгоритмов удаления невидимых поверхностей. Впервые он был предложен Кэтмулом. Алгоритм работает в пространстве изображения, а сама идея $z$-буфера является простым обобщением идеи о буфере кадра, который используется для запоминания атрибутов или интенсивности каждого пикселя в пространстве изображения.

$Z$-буфер --- это отдельный буфер глубины, который используется для запоминания координаты $z$ или глубины каждого видимого пикселя в пространстве изображения. В процессе работы глубина или значение $z$ каждого нового пикселя, который нужно занести в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в $z$-буфере.

Если это сравнение показывает, что новый пиксель расположен впереди пикселя, который находится в буфере кадра, то новое значение заносится в буфер и производится корректировка $z$-буфера новым значением $z$. Если при сравнении получается противоположный результат, то никаких действий не производится.

Алгоритм представляет из себя поиск по каждой точке наибольшего значения функции $z(x, y)$. Формальное описание алгоритма $z$-буфера:

\begin{enumerate}[label=\arabic*)]
	\item заполнить буфер кадра фоновым значением интенсивности или цвета;
	\item провести инициализацию $Z$-буфера минимальным значением глубины;
	\item преобразовать каждый многоугольник в растровую форму в произвольном порядке;
	\begin{enumerate}
		\item для всех пикселей, которые связаны с многоугольником, вычислить его глубину $z(x, y)$;
		\item глубину пикселя сравнить со значением, которое хранится в буфере: если $z(x, y) > z_{buf}(x, y)$, то $z_{buf}(x, y) = z(x, y)$, цвет$(x, y)$ = цвет пикселя;
	\end{enumerate}
	\item отобразить результат.
\end{enumerate}

\img{120mm}{zbuff}{Схема алгоритма, использующего Z-буфер}

\FloatBarrier

\section{Определение принадлежности точки треугольнику}

В векторном определении принадлежности точки треугольнику методе треугольник и точка являются отображением грани и выбранной точки на область отрисовки. 

\img{50mm}{vecdot}{Определение принадлежности точки треугольнику}

\FloatBarrier

На рисунке \ref{img:vecdot} представлен принцип проверки принадлежности точки треугольнику: вектор $\overrightarrow{AP}$ должен выражаться аффинными координатами $(L; M)$, основанными на векторах $\overrightarrow{AB}$ и $\overrightarrow{AC}$. Положительность координат $L$ и $M$ гарантирует нахождение между сторонами $AB$ и $AC$ соответственно. То, что обе координаты меньше 1 и их сумма также меньше 1 гарантирует, что вектор $\overrightarrow{AP}$ не пересекает сторону $BC$.

Следовательно, определить, принадлежит ли точка треугольнику можно с помощью вычисления коэффициентов $m$ и $l$:

\begin{gather*}
	bx = B_{x} - A_{x},
	by = B_{y} - A_{y}, \\
	cx = C_{x} - A_{x},
	cy = C_{y} - A_{y}, \\
	px = P_{x} - A_{x}, 
	py = P_{y} - A_{y}, \\
	\\
	m = (px \cdot by - bx \cdot py) / (cx \cdot by - bx \cdot cy), \\
	\textbf{Если } m > 0, \textbf{то:} \\
	l = (px - m \cdot cx) / bx.
\end{gather*}

В таком случае, если и $m$ и $l$ положительны и в сумме дают не больше 1, то рассматриваемая точка находится внутри треугольника.

\section{Геометрические преобразования}

Для осуществления поворота и перемещения вершин используются аффинные преобразования.

Перемещение точки в пространстве:
\begin{equation*}
	\begin{cases}
		X = x + dx, \\
		Y = y + dy, \\
		Z = z + dz.
	\end{cases}
	\begin{pmatrix}
		1 && 0 && 0 && dx \\
		0 && 1 && 0 && dy \\
		0 && 0 && 1 && dz \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix}
\end{equation*}

Поворот точки в пространстве:
\begin{align*}
	\text{ось } x: 
	\begin{cases}
		X = x, \\
		Y = y \cdot \cos(\phi) + z \cdot \sin(\phi), \\
		Z = - y \cdot \sin(\phi) + z \cdot \cos(\phi).
	\end{cases}
	\begin{pmatrix}
		1 && 0 && 0 && 0 \\
		0 && \cos(\phi) && \sin(\phi) && 0 \\
		0 && -\sin(\phi) && \cos(\phi) && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
	\text{ось }  y: 
	\begin{cases}
		X = x \cdot \cos(\phi) + z \cdot \sin(\phi), \\
		Y = y, \\
		Z = - x \cdot \sin(\phi) + z \cdot \cos(\phi).
	\end{cases}
	\begin{pmatrix}
		\cos(\phi) && 0 && \sin(\phi) && 0 \\
		0 && 1 && 0 && 0 \\
		-\sin(\phi) && 0 && \cos(\phi) && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
	\text{ось }  z: 
	\begin{cases}
		X = x \cdot \cos(\phi) + y \cdot \sin(\phi), \\
		Y = - x \cdot \sin(\phi) + y \cdot \cos(\phi), \\
		Z = z.
	\end{cases}
	\begin{pmatrix}
		\cos(\phi) && \sin(\phi) && 0 && 0 \\
		-\sin(\phi) && \cos(\phi) && 0 && 0 \\
		0 && 0 && 1 && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix} \\
\end{align*}

Масштабирование точки в пространстве:
\begin{equation*}
	\begin{cases}
		X = kx \cdot x, \\
		Y = ky \cdot y, \\
		Z = kz \cdot z.
	\end{cases}
	\begin{pmatrix}
		kx && 0 && 0 && 0 \\
		0 && ky && 0 && 0 \\
		0 && 0 && kz && 0 \\
		0 && 0 && 0 && 1 \\
	\end{pmatrix}
\end{equation*}

\section{Модель освещения}

Для достижения наибольшей производительности в локальная модель освещения делится на две составляющие интенсивности, а именно фоновую освещенность $I_{amb}$ и диффузное отражение $I_{diff}$. Фоновое освещение это постоянная в каждой точке величина надбавки к освещению. Вычисляется следующим образом:
\begin{equation*}
	I_{amb} = k_{a} \cdot I_{a},
\end{equation*}
где $I_{amb}$ --- интенсивность отраженного Ambient-освещения, $k_{a}$ --- коэффициент в пределах от 0 до 1, характеризующий отражающие свойства поверхности для Ambient-освещения, $I_{a}$ --- исходная интенсивность Ambien-освещения, которое падает на поверхность.

Диффузное отражение это свет, отраженный гранью модели:
\begin{equation*}
	I_{diff} = I_{d} \cdot k_{diff} \cdot \cos(\theta),
\end{equation*}
где $I_{d}$ --- интенсивность падающего на поверхность света, $k_{diff}$ --- коэффициент в пределах от 0 до 1, характеризующий рассеивающие свойства поверхности, $\cos(\theta)$ --- угол между направлением на источника света и нормалью поверхности.

Конечная формула принимает вид:
\begin{equation*}
	I = I_{amb} + I_{diff} = k_{a} \cdot I_{a} + I_{d} \cdot k_{diff} \cdot \cos(\theta), 
\end{equation*}
где для более красивого и приятного изображения $k_{a} = 1$, $k_{diff} = 0.8$.

